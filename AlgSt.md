# ВОПРОСЫ ПО АЛГОРИТМАМ И СТРУКТУРАМ ДАННЫХ I курс I семестр

## 1.Оценка сложности алгоритма по времени

**Оценка сложности *по времени*** - сколько операций выполняет программа в зависимости от **количества принимаемых данных**.

- 1 операция — 1 пункт сложности
- 1 итерация = $k$ операций в итерации — $k$ пунктов сложности
- Условие = $k$ логических операций и действий — $k$ пунктов сложности

**T(n)** — функция, описывающая сложность алгоритма *в зависимости **от количества** принимаемых данных*. <br/>
Алгоритмы классифицируют в соответствии с их **временной сложностью**. <br/>
**Точная** оценка алгоритма, тогда и только тогда, когда, верхняя граница $O(n)$ и нижняя граница $\Omega (n)$ ***совпадают***. <br/>
> ![image](https://user-images.githubusercontent.com/104169838/206308976-064476ec-335b-4793-8289-ce7b36fed33c.png) <br/>
> ![image](https://user-images.githubusercontent.com/104169838/206308788-526fc29e-4d60-4464-af68-28fd45a80a9f.png)

**Порядок роста** описывает то, как сложность алгоритма растет с увеличением количества входных данных чаще он представлен в виде О-нотации. **Используем высшую степень, как порядок роста**, потому что она сильнее всех влияет на то, как сложность будет изменяться. <br/>
> [Ссылка на видео лекции КТ](https://youtu.be/8BniwdaAUMc?list=PLrS21S1jm43jz48qjdfYNpuIPgL3lNJ_o) <br/>
> [Сыллка на лекцию Нияза Нигматуллина (CSC)](https://www.youtube.com/watch?v=k850DNwR9xw) <br/>

## 2. Оценка сложности алгоритма по памяти.

Оценка сложности по памяти - сколько занимает памяти алгоритм.

- 1 переменная — 1 пункт сложности
- Массив размером n — n пунктов сложности
- Строка длинной n — n пунктов сложности

Оценка сложности алгоритма по памяти оценивает только **дополнительную память**, используемую алгоритмом. $М(n)$ — функция, оценивающая сложность по памяти. <br/>

Есть **3 функции** оценивающие память: $O$, $\Theta$, $\Gamma$. <br/>

Так же, как и в случае с оценкой по времени:
1. $O$ - верхняя граница
2. $\Theta$ - точная оценка
3. $\Gamma$ - нижняя оценка

**NB! РЕКУРСИВНЫЙ ВЫЗОВ ТРАТИТ ПАМЯТЬ**

![Не очень подходит для оценки по памяти, но +- представление](https://user-images.githubusercontent.com/104169838/206311387-6f062c33-7c2e-4911-b84d-4b947800f90f.png)

## 3. Сортировка вставками

**Принцип сортировки вставками:**
- Первый элемент считается отсортированным (инвариант*)
- Просматриваем элементы слева направо от $j + 1$ и до конца.
- Выполняем вставку отсортированного элемента в отсортированную часть
- После вставки увеличиваем отсортированную часть на 1.

**Инвариант** - утверждение, которое верно **до** выполнения цикла, **во время** выполнения цикла и **после** выполнения цикла
![image](https://user-images.githubusercontent.com/104169838/206312830-2ce73e0a-9def-4939-8960-85f432194855.png)

### Cложность:

**По времени:**

- Лучший случай O(n) (если массив и так отсортирован)
- Средний случай O(n^2)
- Худший случай (если массив отсортирован наоборот)
**По памяти:**
- Во всех случаях O(1), потому что используем одну переменную во всех случаях.
### Реализации:
- Меняем элемент, который хотим вставить каждый раз при сравнении его с другими элементами
- Сравниваем элемент с элементами отсортированной части и двигаем её пока не найдем позицию нашего элемента.

### Код:

Реализация второго способа.
```cpp
 for (int j = 1; j <= length; j++) {
    key = a[j];
    i = j - 1;
    while (int i > 0 && a[i] > key) {
       a[i + 1] = a[i];
       i--;
    }
    a[i + 1] = key;
}
```

## 4. Сортировка слиянием

### Принцип сортировки слиянием:**

- На рекурсивном спуске разбиваем массив напополам пока длина итоговых массивов не будет меньше или равна 1.
- На рекурсивном подъёме сливаем полученные массивы в отсортированный массив.

## Рекурсивный спуск (красный) и рекурсивный подъем (зеленый):

![image](https://user-images.githubusercontent.com/104169838/206314116-7e762cb0-b8ef-466b-b669-0425dc5ae7c2.png)

### Сложность алгоритма:

**Сложность по времени:**

- Во всех случаях сложность: O(nlogn), где n это для слияния, а logn для разбиения.

**Сложность по памяти:**

- Сложность O(n), потому что нужен вспомогательный массив.

### Код:

> Merge — алгоритм слияния двух массивов. <br/>
> MergeSort — сама сортировка слиянием. <br/>

```cpp
void Merge(int* array, int left, int middle, int right) {

    int lb = middle - left + 1;
    int rb = right - middle;

    int L[lb];
    int R[rb];

    for (int i = 0; i < lb; i++) {
        L[i] = array[left + i];
    }
    for (int j = 0; j < rb; j++) {
        R[j] = array[middle + 1 + j];
    }

    int i = 0;  //L[1]
    int j = 0;  //R[1]
    int k = left;  

    while (i < lb && j < rb) {
        if (L[i] <= R[j]) {
            array[k] = L[i];
            i++;
        }
        else {
            array[k] = R[j];
            j++;
        }
        k++;
    }

    while (i < lb) {
        array[k] = L[i];
        i++;
        k++;
    }
    while (j < rb) {
        array[k] = R[j];
        j++;
        k++;
    }
}

void MergeSort(int* array, int left, int right) {
    if (left < right){
        int med = left + (right - left) / 2;
        MergeSort(array, left, med);
        MergeSort(array, med + 1, right);
        Merge(array, left, med,  right);
    }
}

```
>[Ссылка на видео лекции КТ](https://www.youtube.com/watch?v=8BniwdaAUMc&list=PLrS21S1jm43jz48qjdfYNpuIPgL3lNJ_o) <br/>
>[Сыллка на лекцию Нияза Нигматуллина (CSC)](https://www.youtube.com/watch?v=MMBi2m2RHrQ&list=PLlb7e2G7aSpTZN_zRrbpVJUvB-pTuM_VL&index=2)

## 5. Быстрая сортировка

### Принцип работы Быстрой сортировки:
![image](https://commons.wikimedia.org/wiki/File:Sorting_quicksort_anim.gif#/media/Файл:Sorting_quicksort_anim.gif)


### Разбиение Ломуто:

- За опорный элемент берётся последний неотсортированного массива
- Ставим два указателя i И j на первый элемент, где j — указатель на первый элемент, который больше опорного, а i указатель на часть массива без опорного.
- Если элемент под i-тым индексом меньше опорного мы свапаем его с j-тым элементом и увеличиваем оба указателя на 1.
- Если элемент под i-тым указателем больше опорного, то увеличиваем только i-тый указатель.
- Как только мы дошли i-тым указателем до последнего, то свапаем последний элемент с j-тым.
- Рекурсивно выполняем Быструю сортировку для массива 0 до j-1 элемента и для j + 1 до i.

### Разбиение Хоара:

### Код:
> вызывать так: quickHoar(arr, 0, n - 1) <br/>
> n - длина массива arr


```cpp
void quickHoara(int* mas, int left, int right) {
    if (left >= right) {
        return;
    }
    int left_pointer = left;
    int right_pointer = right;
    int pivot = mas[(left + right)/2];
    while (left_pointer <= right_pointer) {
        while (mas[left_pointer] < pivot) left_pointer++;
        while (mas[right_pointer] > pivot) right_pointer--;
        if (left_pointer <= right_pointer) {
            swap(mas[left_pointer], mas[right_pointer]);
            left_pointer++;
            right_pointer--;
        }
    }
    quickHoara(mas, left, right_pointer);
    quickHoara(mas, left_pointer, right);
}
```

[Ссылка на видео лекции КТ](https://www.youtube.com/watch?v=CWiDEus3rDA&list=PLrS21S1jm43jz48qjdfYNpuIPgL3lNJ_o&index=3) <br/>
[Сыллка на лекцию Нияза Нигматуллина (CSC)](https://www.youtube.com/watch?v=kaIP2dkBlbQ&list=PLlb7e2G7aSpTZN_zRrbpVJUvB-pTuM_VL&index=3)
