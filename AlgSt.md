# ВОПРОСЫ ПО АЛГОРИТМАМ И СТРУКТУРАМ ДАННЫХ I курс I семестр

## 1.Оценка сложности алгоритма по времени

**Оценка сложности *по времени*** - сколько операций выполняет программа в зависимости от **количества принимаемых данных**.

- 1 операция — 1 пункт сложности
- 1 итерация = $k$ операций в итерации — $k$ пунктов сложности
- Условие = $k$ логических операций и действий — $k$ пунктов сложности

**T(n)** — функция, описывающая сложность алгоритма *в зависимости **от количества** принимаемых данных*. <br/>
Алгоритмы классифицируют в соответствии с их **временной сложностью**. <br/>
**Точная** оценка алгоритма, тогда и только тогда, когда, верхняя граница $O(n)$ и нижняя граница $\Omega (n)$ ***совпадают***. <br/>
> ![image](https://user-images.githubusercontent.com/104169838/206308976-064476ec-335b-4793-8289-ce7b36fed33c.png) <br/>
> ![image](https://user-images.githubusercontent.com/104169838/206308788-526fc29e-4d60-4464-af68-28fd45a80a9f.png)

**Порядок роста** описывает то, как сложность алгоритма растет с увеличением количества входных данных чаще он представлен в виде О-нотации. **Используем высшую степень, как порядок роста**, потому что она сильнее всех влияет на то, как сложность будет изменяться. <br/>
> [Ссылка на видео лекции КТ](https://youtu.be/8BniwdaAUMc?list=PLrS21S1jm43jz48qjdfYNpuIPgL3lNJ_o) <br/>
> [Сыллка на лекцию Нияза Нигматуллина (CSC)](https://www.youtube.com/watch?v=k850DNwR9xw) <br/>

## 2. Оценка сложности алгоритма по памяти.

Оценка сложности по памяти - сколько занимает памяти алгоритм.

- 1 переменная — 1 пункт сложности
- Массив размером n — n пунктов сложности
- Строка длинной n — n пунктов сложности

Оценка сложности алгоритма по памяти оценивает только **дополнительную память**, используемую алгоритмом. $М(n)$ — функция, оценивающая сложность по памяти. <br/>

Есть **3 функции** оценивающие память: $O$, $\Theta$, $\Gamma$. <br/>

Так же, как и в случае с оценкой по времени:
1. $O$ - верхняя граница
2. $\Theta$ - точная оценка
3. $\Gamma$ - нижняя оценка

**NB! РЕКУРСИВНЫЙ ВЫЗОВ ТРАТИТ ПАМЯТЬ**

![Не очень подходит для оценки по памяти, но +- представление](https://user-images.githubusercontent.com/104169838/206311387-6f062c33-7c2e-4911-b84d-4b947800f90f.png)

## 3. Сортировка вставками

**Принцип сортировки вставками:**
- Первый элемент считается отсортированным (инвариант*)
- Просматриваем элементы слева направо от $j + 1$ и до конца.
- Выполняем вставку отсортированного элемента в отсортированную часть
- После вставки увеличиваем отсортированную часть на 1.

**Инвариант** - утверждение, которое верно **до** выполнения цикла, **во время** выполнения цикла и **после** выполнения цикла
![image](https://user-images.githubusercontent.com/104169838/206312830-2ce73e0a-9def-4939-8960-85f432194855.png)

### Cложность:

**По времени:**

- Лучший случай $O(n)$ (если массив и так отсортирован)
- Средний случай $O(n^2)$
- Худший случай (если массив отсортирован наоборот) $O(n^2)$ <br/>

**По памяти:**
- Во всех случаях $O(1)$, потому что используем одну переменную во всех случаях.

### Устойчивость
***УСТОЙЧИВ***
### Реализации:
- Меняем элемент, который хотим вставить каждый раз при сравнении его с другими элементами
- Сравниваем элемент с элементами отсортированной части и двигаем её пока не найдем позицию нашего элемента.

### Код:

Реализация второго способа.
```cpp
 for (int j = 1; j <= length; j++) {
    key = a[j];
    i = j - 1;
    while (int i > 0 && a[i] > key) {
       a[i + 1] = a[i];
       i--;
    }
    a[i + 1] = key;
}
```

## 4. Сортировка слиянием

### Принцип сортировки слиянием:**

- На рекурсивном спуске разбиваем массив напополам пока длина итоговых массивов не будет меньше или равна 1.
- На рекурсивном подъёме сливаем полученные массивы в отсортированный массив.

## Рекурсивный спуск (красный) и рекурсивный подъем (зеленый):

![image](https://user-images.githubusercontent.com/104169838/206314116-7e762cb0-b8ef-466b-b669-0425dc5ae7c2.png)

### Сложность алгоритма:

**Сложность по времени:**

- Во всех случаях сложность: $O(n \cdot logn)$, где n это для слияния, а $logn$ для разбиения.

**Сложность по памяти:**

- Сложность $O(n)$, потому что нужен вспомогательный массив.

### Устойчивость
***УСТОЙЧИВАЯ***

### Код:

> Merge — алгоритм слияния двух массивов. <br/>
> MergeSort — сама сортировка слиянием. <br/>

```cpp
void Merge(int* array, int left, int middle, int right) {

    int lb = middle - left + 1;
    int rb = right - middle;

    int L[lb];
    int R[rb];

    for (int i = 0; i < lb; i++) {
        L[i] = array[left + i];
    }
    for (int j = 0; j < rb; j++) {
        R[j] = array[middle + 1 + j];
    }

    int i = 0;  //L[1]
    int j = 0;  //R[1]
    int k = left;  

    while (i < lb && j < rb) {
        if (L[i] <= R[j]) {
            array[k] = L[i];
            i++;
        }
        else {
            array[k] = R[j];
            j++;
        }
        k++;
    }

    while (i < lb) {
        array[k] = L[i];
        i++;
        k++;
    }
    while (j < rb) {
        array[k] = R[j];
        j++;
        k++;
    }
}

void MergeSort(int* array, int left, int right) {
    if (left < right){
        int med = left + (right - left) / 2;
        MergeSort(array, left, med);
        MergeSort(array, med + 1, right);
        Merge(array, left, med,  right);
    }
}

```
>[Ссылка на видео лекции КТ](https://www.youtube.com/watch?v=8BniwdaAUMc&list=PLrS21S1jm43jz48qjdfYNpuIPgL3lNJ_o) <br/>
>[Сыллка на лекцию Нияза Нигматуллина (CSC)](https://www.youtube.com/watch?v=MMBi2m2RHrQ&list=PLlb7e2G7aSpTZN_zRrbpVJUvB-pTuM_VL&index=2)

## 5. Быстрая сортировка

### Принцип работы Быстрой сортировки:
![Sorting_quicksort_anim](https://user-images.githubusercontent.com/104169838/206319416-3b78603e-7fe1-445c-b2c5-f336a2a9f6cb.gif)

### Сложность алгоритма:

**Сложность по времени:**
- Лучший: $O(n \cdot logn)$
- Средний: $O(n \cdot logn)$
- Худший: $O(n^2)$

**Сложность по памяти:**
- $O(n)$ - дополнительная память на массив
- $O(logn)$ - необходимо памяти на спуск <br/>

Требует лишь $O(1)$ дополнительной памяти для своей работы (неулучшенный рекурсивный алгоритм - в худшем случае $O(n)$ памяти

### Устойчивость
***НЕ УСТОЙЧИВ***


### Разбиение Ломуто:

- За опорный элемент берётся последний неотсортированного массива
- Ставим два указателя $i$ И $j$ на первый элемент, где $j$ — указатель на первый элемент, который больше опорного, а $i$ указатель на часть массива без опорного.
- Если элемент под $i$-тым индексом меньше опорного мы свапаем его с $j$-тым элементом и увеличиваем оба указателя на 1.
- Если элемент под $i$-тым указателем больше опорного, то увеличиваем только $i$-тый указатель.
- Как только мы дошли $i$-тым указателем до последнего, то свапаем последний элемент с $j$-тым.
- Рекурсивно выполняем Быструю сортировку для массива 0 до $j-1$ элемента и для $j + 1$ до $i$.

#### Псевдокод с wikipedia.com
```
algorithm partition(A, low, high) is
    pivot := A[high]
    i := low
    for j := low to high - 1 do
        if A[j] ≤ pivot then
            swap A[i] with A[j]
            i := i + 1
    swap A[i] with A[high]
    return i
```

### Разбиение Хоара:
#### Псевдокод с wikipedia.com
```
algorithm quicksort(A, lo, hi) is
   if lo < hi then
       p:= partition(A, lo, hi)
       quicksort(A, lo, p)
       quicksort(A, p + 1, hi)
algorithm partition(A, low, high) is
   pivot:= A[(low + high) / 2]
   i:= low
   j:= high
   loop forever
       
       while A[i] < pivot 
              i:= i + 1
       while A[j] > pivot
              j:= j - 1
       if i >= j then
           return j
       swap A[i++] with A[j--]
```

### Код:
> вызывать так: quickHoar(arr, 0, n - 1) <br/>
> n - длина массива arr

```cpp
void quickHoara(int* mas, int left, int right) {
    if (left >= right) {
        return;
    }
    int left_pointer = left;
    int right_pointer = right;
    int pivot = mas[(left + right)/2];
    while (left_pointer <= right_pointer) {
        while (mas[left_pointer] < pivot) left_pointer++;
        while (mas[right_pointer] > pivot) right_pointer--;
        if (left_pointer <= right_pointer) {
            swap(mas[left_pointer], mas[right_pointer]);
            left_pointer++;
            right_pointer--;
        }
    }
    quickHoara(mas, left, right_pointer);
    quickHoara(mas, left_pointer, right);
}
```

[Ссылка на видео лекции КТ](https://www.youtube.com/watch?v=CWiDEus3rDA&list=PLrS21S1jm43jz48qjdfYNpuIPgL3lNJ_o&index=3) <br/>
[Сыллка на лекцию Нияза Нигматуллина (CSC)](https://www.youtube.com/watch?v=kaIP2dkBlbQ&list=PLlb7e2G7aSpTZN_zRrbpVJUvB-pTuM_VL&index=3)

## 6. Сортировка подсчетом

**Есть 2 вида сортировки:**
- Не устойчивая
- Устойчивая

### 1. Не устойчивая  

**Принцип работы:** 

Мы создаём доп. массив длинны K, где к это мощность используемого алфавита. Например, если мы знаем, что в массиве хранятся только числа от 0-9, то доп. массив у нас будет на 10 элементов. Далее проходимся по нашему исходному массиву и инициализируем доп. массив так, чтобы число “ i ” встречалось в исходном массиве C[i] раз.

Далее просто пробегаемся по доп. массиву и выводим  c[i] раз “ i ”.

### 2. Устойчивая

Начинается, как и неустойчивая, мы так же заполняем доп. массив, но потом мы пробегаемся по нему еще раз от 1 до (доп_мас.size() - 1) и каждому элемент становится равен себе + значение в предыдущей ячейке. Таким образом у нас в C[i] ячейке лежит id+1 ячейки в исходном массиве, где после сортировки должен лежать i-й элемент. Далее мы создаем новый массив с результатом сортировки просто пробегаемся от (мас.size() - 1) до 0 и ставим элемент из исходного массива (i) на C[i]-1 позицию в массив с результатом сортировки.

Cложность алгоритмов:

По времени O(n + k), т.к. время работы зависит от того,  насколько большой алфавит нам придется взять для составления доп. массива

По памяти O(n + k), K элементов на доп. массив + n на основной

В основном применяется, когда k == n (мощность алфавита равна входным данным)

!TODO
